% $Author$
% $Date$
% $Revision$
%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage{times,german,tabularx}
	\usepackage[
		papersize={6in,9in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	\renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================
\chapter{Eine erste Anwendung}
\label{cha:firstApp}

In diesem Kapitel werden wir ein einfaches Spiel entwickeln: \ind{Quinto}. Dabei werden wir die meisten Werkzeuge zeigen, die \squeak Squeak-Entwickler verwenden, um ihre Programme zu konstruieren und zu debuggen und zeigen, wie Programme zwischen Entwicklern ausgetauscht werden können. Wir werden den System-Browser, den Objekt-Inspektor, den Debugger und den  \ind{Monticello} \ind{package} Browser sehen. Entwicklung in Smalltalk ist effizient: du wirst feststellen, dass du viel mehr Zeit damit verbringst, wirklichen Quelltext zu schreiben und viel weniger Zeit damit, den Entwicklungsprozess zu verwalten. Das liegt zum Teil daran, dass die Sprache Smalltalk sehr einfach ist und zum Teil daran, dass die Werkzeuge sehr gut in die Sprache integriert sind. 


%=================================================================
\section{Das Spiel Quinto}

% DON'T USE WRAPFIGURE CLOSE TOO A PAGE BREAK!!! (ON)
%\begin{wrapfigure}[13]{r}{0.35\linewidth}%
%	\vskip -\baselineskip
%	\centerline{\includegraphics[width=.8\linewidth]{Spielfeld}}
%	\caption{The Quinto game board. The user has just clicked the mouse as shown by the cursor.
%	\label{fig:gameBoard}}
%\end{wrapfigure}

\begin{figure}[ht]
	\vskip -\baselineskip
	\centerline{\includegraphics[width=.3\linewidth]{GameBoard}}
	\caption{Das Quinto-Spielfeld. Der Spieler hat gerade mit der Maus geklickt, wie der Cursor anzeigt
	\label{fig:Spielfeld}}
\end{figure}

Um zu zeigen, wie man die Programmierwerkzeuge von \squeak verwendet, wollen wir ein einfaches Spiel namens \emph{Quinto} bauen. Das Spielfeld ist in \figref{Spielfeld} zu sehen, es besteht aus rechteckigen Feld hellgelber \emph{Zellen}. Wenn du auf eine dieser Zellen mit der Maus klickst, färben sich die angrenzenden Zellen blau. Wenn du nochmals klickst, wechseln sie zurück auf hellgelb. Das Ziel des Spiels ist es, so viele Zellen wie möglich blau zu färben.
Das Quinto-Spiel aus \figref{Spielfeld} besteht aus zwei Arten von Objekten: das Spielfeld selbst und 100 einzelne Zell-Objekte. Der \squeak Quelltext für dieses Spiel wird zwei Klassen enthalten: eine für das Spiel und eine für die Klasse. Wir wollen nun zeigen, wie du diese Klassen mit den  \squeak Programmierwerkzeugen definieren kannst.


%=================================================================
\section{Eine neue Klassenkategorie erzeugen}

Den \ind{System Browser} haben wir schon in \charef{quick} gesehen, wo wir gelernt haben, zu Klassen und Methoden zu navigieren und wie man  neue Methoden definiert. Nun sehen wir, wir man System-Kategorien und Klassen erzeugt. 

\seeindex{System Kategorie}{Kategorie}
\seeindex{Klassenkategorie}{System Kategorie}
\index{Kategorie!erzeugen}

\dothis{Öffne einen System-Browser und klicke mit der gelben Maustaste in die Kategorie-Spalte. Wähle  \menu{add item \ldots}.}

\begin{figure}[htb]
\begin{minipage}[b]{0.48\textwidth}
\ifluluelse
	{\centerline {\includegraphics[width=0.9\textwidth]{AddCategory}}}
	{\centerline {\includegraphics[scale=0.7]{AddCategory}}}
	\caption{Eine System-Kategorie hinzufügen.
	\label{fig:addCategory}}
\end{minipage}
\hfill
\begin{minipage}[b]{0.48\textwidth}
\ifluluelse
	{\centerline {\includegraphics[width=0.9\textwidth]{ClassTemplate}}}
	{\centerline {\includegraphics[scale=0.7]{ClassTemplate}}}
	\caption{Das Template für die Klassenerzeugung.
	\label{fig:classTemplate}}
\end{minipage}
\end{figure}

Tippe den Namen der neuen Kategorie (wir verwenden \scat{SBE-Quinto}) in das Dialogfenster und klicke auf \menu{OK} (oder drücke einfach die ENTER-Taste); die neue Kategorie ist erzeugt und befindet sich am Ende der Kategorienliste. Hast du vorher schon eine existierende Kategorie ausgewählt, dann wird die neue Kategorie direkt davor angeordnet.

%=================================================================
\section{Die Klasse SBEZelle definieren}

Jetzt sind natürlich noch keine Klassen in dieser Kategorie. Trotzdem zeigt das Haupt-Editor-Fenster bereits eine Vorlage, die es erleichtert, eine neue Klasse zu erzeugen (see \figref{classTemplate}). 

Diese Vorlage zeigt einen \st Ausdruck, der eine Nachricht an eine Klasse namens \ct{Object} schickt und es auffordert, eine Unterklasse namens \ct{NameOfSubClass} zu erzeugen. Die neue Klasse hat keine Variablen und soll in die Kategorie \scat{SBE-Quinto} gehören. 
Wir verändern einfach die Vorlage, um die Klasse zu erzeugen, die wir wirklich haben wollen. 


\dothis{Verändere die Klassen-Vorlage wie folgt:}
\begin{itemize}
  \item Ersetze \clsind{Object} durch \clsind{SimpleSwitchMorph}.
  \item Ersetze \ct{NameOfSubClass} durch \clsind{SBEZelle}.
  \item Füge \ct{mausAktion} zur Liste der Instanzvariablen hinzu.
\end{itemize}

Das Ergebnis sollte aussehen wie \clsref{firstClassDef}.

\begin{classdef}[firstClassDef]{Definition der Klasse \ct| SBEZelle|}
SimpleSwitchMorph subclass: #SBEZelle
   instanceVariableNames: 'mausAktion'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'SBE-Quinto'
\end{classdef}
\index{System Browser!Definition einer Klasse}
\index{Klasse!Erzeugung}
\index{Morphic}

Diese neue Definition besteht aus einem \st Ausdruck, der eine Nachricht an die existierende Klasse \ct{SimpleSwitchMorph} schickt und es auffordert, eine Unterklasse namens \ct{SBEZelle} zu erzeugen (Genau genommen, da \ct{SBEZelle} jetzt noch nicht existiert, übergeben wir \emphind{symbol} \ct{#SBEZelle} als Argument, was für den Namen der Klasse steht, die erzeugt werden soll). Wir sagen auch, dass Instanzen der neuen klasse eine Instanzvariable namens \ct{mausAktion} haben sollen, welche wir nutzen wollen, um zu definieren, welche Aktion die Zelle ausführen soll, wenn mit der Maus darauf geklickt wird

\emph{An diesem Punkt hast du noch nichts erzeugt.}
Beachte, dass der Rand des Editorfensters mit der Klassenvorlage rot gefärbt ist (\figref{acceptClassDef}). Das bedeutet, dass sich dort \emph{ungesicherte Änderungen} befinden. Um diese Nachricht wirklich zu senden, musst du sie \menu{accept}. 

\begin{figure}[h!t]
\ifluluelse
	{\centerline {\includegraphics[width=\textwidth]{AcceptClassDef}}}
	{\centerline {\includegraphics[scale=0.7]{AcceptClassDef}}}
\caption{Die Vorlage zur Klassenerzeugung.
\label{fig:acceptClassDef}}
\end{figure}

\dothis{Akzeptiere die neue Klassendefinition.}

Klicke entweder mit der gelben Maustaste und wähle \menu{OK}oder verwende den Tastatur-Kurzbefehl \short{s} (für sichern). Die Nachricht wird an \ct{SimpleSwitchMorph} gesendet, was dazu führt, dass die neue Klasse kompiliert wird. 

\index{gelbe Maustaste}
\index{Tastatur Kurzbefehl!OK}

Wenn die Klassendefinition akzeptiert ist, wird die Klasse erzeugt und erscheint in der Klassen-spalte des Browsers (\figref{SBEZelle}). 
Das Editorfenster zeigt nun die Klassendefinition und eine schmale Zeile darunter erinnert dich daran, ein paar Worte zu schreiben, um den Zweck der Klasse zu beschreiben. Das nennt man einen \emph{Klassenkommentar} und es ist sehr wichtig, einen zu schreiben, denn er gibt anderen Programmierern einen allgemeinen Überblick über den Zweck dieser Klasse. Smalltalker messen der Lesbarkeit ihres Quelltextes großen Wert bei, und detaillierte Kommentare in Methoden sind ungewöhnlich: die Philosophie ist, dass der Quelltext für sich selbst spricht. (Ist das nicht der Fall, solltest du ihn überarbeiten!) Ein \subind{Klassenkommentar} muss keine ausführliche Beschreibung der Klasse enthalten, aber ein paar Worte, die den prinzipiellen Zweck beschreiben, sind unerlässlich, wenn Programmierer später entscheiden sollen, ob es sich für sie lohnt, sich diese Klasse genauer anzusehen. 
\index{refactoring}

\dothis{Tippe einen Klassenkommentar für  \ct{SBEZelle}, du kannst ihn später immer noch verbessern.} 

\begin{figure}[h!t]
\ifluluelse
	{\centerline {\includegraphics[width=\textwidth]{SBEZelle}}}
	{\centerline {\includegraphics[scale=0.7]{SBEZelle}}}
\caption{Die neu erzeugte Klasse \ct{ SBEZelle}\label{fig:SBEZelle}}
\end{figure}

%=================================================================
\section{Methoden zu einer Klasse hinzufügen}

Nun wollen wir ein paar Methoden zu unserer Klasse hinzufügen.

\dothis{Wähle das Protokoll \prot{-{}-all-{}-} aus der Protokoll-Spalte.}

Du wirst eine Methoden-Vorlage im Editorfenster sehen. Wähle sie aus und ersetze sie durch den Text von \mthref{scbecellinitialize}.

\protindex{all}
\index{Methode!Erzeugung}
\index{System Browser!definieren einer Methode}

\needlines{10}
\begin{numMethod}[scbecellinitialize]{nitialisierung der Instanzen von \ct{SBEZelle}}
initialize
   super initialize.
   self label: ''.
   self borderWidth: 2.
   bounds := 0@0 corner: 16@16.
   offColor := Color paleYellow.
   onColor := Color paleBlue darker.
   self useSquareCorners.
   self turnOff
\end{numMethod}
\index{initialization}

\noindent

Beachte dass die \ct{''} - Zeichen in Zeile 3 zwei einzelne Anführungszeichen ohne Zwischenraum sind und kein doppeltes Anführungszeichen. \ct{''} bezeichnet eine leere Zeichenkette. 



\dothis{\menu{OK} Akzeptiere diese Methodendefinition.}

Was tut der obige Quelltext? Wir wollen uns hier nicht jedes Detail ansehen (dazu ist der Rest des Buches da!), aber wir wollen einen kurzen Überblick geben. Lass uns Zeile für Zeile ansehen. 

Beachte, dass der Name der Methode \mthind{SBEZelle}{initialize} ist. Der Name ist sehr wichtig! Es ist eine Konvention, dass wenn eine Klasse eine Methode namens \ct{initialize} definiert, diese direkt nach der Erzeugung eines Objektes aufgerufen wird. Wenn wir \ct{SBEZelle new} auswerten, wird die Nachricht \ct{initialize} automatisch an das neu erzeugte Objekt gesendet. Initialisierungs-Methoden werden verwendet, um einen bestimmten Objektstatus herzustellen, typischerweise, um seine Instanzvariablen zuzuweisen, das ist genau das, was wir hier tun.

\seeindex{Objekt!Initialisierung}{Initialisierung}
\index{Initialisierung}

Das erste, was die Methode tut (Zeile 2), ist das Ausführen der Methode \ct{initialize} seiner Oberklasse, \ct{SimpleSwitchMorph}. Die Idee ist hier, dass jeder geerbte Status richtig initialisiert wird durch die \ct{initialize}-Methode der Oberklasse. Es ist immer eine gute Idee, den geerbten Status zu initialisieren, indem man super initialize sendet, bevor man irgendetwas anderes tut. Wir wissen nicht genau, was die \ct{initialize}-Methode vom \ct{SimpleSwitchMorph} tut, und es ist uns auch egal, aber wir könnten wetten, dass einigen Instanzvariablen sinnvolle Standardwerte zugewiesen werden, also sollten wir sie lieber aufrufen, oder wir riskieren es, in einem unklaren Zustand zu starten. 

Der Rest der Methode stellt einen Zustand des Objektes her. Durch das Senden von  \ct{self label: ''} wird beispielsweise die Beschriftung dieses Objektes auf eine leere Zeichenkette gesetzt.
\pvindex{self}

Der Ausdruck \ct{0@0 corner: 16@16} bedarf wahrscheinlich einer Erläuterung. \lct{0@0} stellt ein \clsind{Point}-Objekt dar, dessen $x$ und $y$ Koordinaten beide auf 0 gesetzt sind. Tatsächlich sendet \ct{0@0} die Nachricht @ an die Zahl \ct{0} mit dem Argument \ct{0}. Der Effekt davon ist, dass die Zahl \ct{0} die Klasse \ct{Point} auffordert, eine neue Instanz mit den Koordinaten (0,0) zu erzeugen. Nun senden wir diesem neu erzeugten Point die Nachricht \ct{corner: 16@16}, was es dazu bewegt, ein \clsind{Rechteck} mit den Eckpunkten \ct{0@0} und \ct{16@16} zu erzeugen. Dieses neu erzeugte Rechteck wird der \ct{bounds}-Variable zugewiesen, die von der Oberklasse geerbt wurde.
Beachte, dass der Ursprung des \sq -Bildschirms \emph{oben links} ist und die $y$-Koordinate sich \emph{abwärts} erhöht.
Der Rest der Methode sollte selbsterklärend sein. Teil der Kunst, guten \st-Quelltext zu schreiben, ist es, gute Methodennamen auszuwählen, so dass man \st-Quelltext wie eine Art Pidgin-Englisch lesen kann. Du solltest in der Lage sein, dir das Objekt vorzustellen, wie es mit sich selber spricht und sagt ``\ct{Self use square corners!}'',``\ct{Self turn off!}''.

%=================================================================
\section{Ein Objekt untersuchen}

Du kannst die Auswirkungen des Quelltextes, den du geschrieben hast, testen, indem du ein neues \ct{SBEZelle}-Objekt erzeugst und untersuchst. 

\dothis{Öffne einen Workspace. Tippe den Ausdruck \ct{SBEZelle new} und \menu{Untersuchen}.}

\begin{figure}[htbp]
   \centering
   \includegraphics[scale=0.7]{SBEZelleInspektor} 
   \caption{Der Inspektor wird benutzt, um ein SBEZelle-Objekt zu untersuchen.\label{fig:SBEZelleInspektor}}
\end{figure}

Die linke Spalte im  \ind{Inspektor} zeigt eine Liste der Instanzvariablen; wenn du eine auswählst (versuch es mit \ct{bounds}, wird der Wert der \ind{Instanzvariable} in der rechten Spalte angezeigt. Du kannst den Inspektor auch benutzen, um den Wert einer Instanzvariable zu verändern. 


\dothis{Verändere den Wert von \ct{bounds} zu \ct{0@0 corner: 50@50} und \menu{OK}.}

Die Fußzeile des Inspektors ist ein Mini-Workspace. Er ist nützlich, weil in diesem Workspace die Pseudo-Variable \self an das Objekt gebunden ist, das untersucht wird.

\dothis{Tippe den Text \ct{self openInWorld} in die Fußzeile und \menu{Ausführen}.}

Die Zelle sollte in der linken oberen Ecke des Bildschirms erscheinen, in der Tat genau da, wo ihre \ct{bounds} angeben, dass sie erscheinen sollte. Ein Klick mit der blauen Maustaste öffnet die \subind{Morphic}{Smarties}. Bewege die Zelle mit dem braunen Smartie (oben rechts)und verändere die Größe mit dem gelben Smartie (unten rechts). Beachte, wie die bounds  im Inspektor sich ebenfalls verändern!

\begin{figure}[htbp]
\centering
\ifluluelse
	{\includegraphics[width=\textwidth]{SBECellResize} }
	{\includegraphics[scale=0.7]{SBECellResize} }
\caption{Verändern der Größe der Zelle.\label{fig:cellresize}}
\end{figure}

\dothis{Lösche die Zelle, indem du auf das rosa Smartie mit dem  \ct{x} klickst.}


%=================================================================
\section{Definition der Klasse SBESpiel}

Nun wollen wir die andere Klasse definieren, die wir für unser Spiel brauchen, die wir \clsind{SBESpiel} nennen wollen. 


\dothis{Zeige die Vorlage für die Klassendefinition im Editorfenster des Browsers an.}

Tu das, indem du zweimal auf den Namen der bereits ausgewählten Klassenkategorie klickst oder die Definition von \ct{SBEZelle} nochmals anzeigst (durch Klick auf den \button{instance}-Knopf.) Editiere den Quelltext, so dass er wie folgt lautet und \menu{OK}: 

\needlines{6}
\begin{classdef}[sbegame]{Definition der Klasse \ct{SBESpiel}}
BorderedMorph subclass: #SBESpiel
   instanceVariableNames: ''
   classVariableNames: ''
   poolDictionaries: ''
   category: 'SBE-Quinto'
\end{classdef}

Hier erzeugen wir eine Unterklasse von \clsind{BorderedMorph}; \clsind{Morph} ist die Oberklasse aller graphischen Formen in \squeak und (Überraschung!) ein \ct{BorderedMorph} ist ein \ct{Morph} mit einem Rand. Wir könnten auch die Namen der Instanzvariablen zwischen den Anführungszeichen in der zweiten Zeile einsetzen, aber erstmal lassen wir diese Liste leer. 

Nun wollen wir eine  \mthind{initialize}-Methode für \ct{SBESpiel} definieren. 

\dothis{Tippe das Folgende als Methode für \ct{SBESpiel} in den Browser und versuche es mit \menu{OK} zu übersetzen:}

\begin{numMethod}[sbegameinitialize]{Initialisierung des Spiels}
initialize
   | musterZelle breite hoehe n |
   super initialize.
   n := self zellenProSeite.
   musterZelle := SBEZelle new.
   breite := musterZelle width.
   hoehe := musterZelle height.
   self bounds: (5@5 extent: ((width*n) @(height*n)) + (2 * self borderWidth)).
   cells := Matrix new: n tabulate: [ :i :j | self neueZelleBei: i bei: j ].
\end{numMethod}

%\sd{it would be nicer if we would not have to create an instance of SBECell for nothing}
%\on{yes}


\squeak wird beanstanden, dass es die Bedeutung einiger Terme nicht kennt. \squeak teilt dir mit, dass es keine Nachricht \ct{zellenProSeite} kennt und schlägt eine Reihe von Korrekturen vor für den Fall, dass ein Schreibfehler vorliegt. 

\begin{figure}[htb]
\begin{minipage}{0.34\textwidth}
	\centering
	\ifluluelse
		{\includegraphics[width=\textwidth]{UnknownSelector}}
		{\includegraphics[scale=0.7]{UnknownSelector}}
	\caption{\squeak entdeckt einen unbekannten Selektor.\label{fig:unknownSelector}}
\end{minipage}
\hfill
\begin{minipage}{0.64\textwidth}
	\centering
	\ifluluelse
		{\includegraphics[width=\textwidth]{DeclareInstanceVar}}
		{\includegraphics[scale=0.7]{DeclareInstanceVar}}
	\caption{Deklaration einer neuen Instanzvariable.\label{fig:declareInstance}}
\end{minipage}
\end{figure}

Aber \ct{zellenProSeite} ist kein Fehler\,---\,es ist nur eine Methode, die wir noch nicht definiert haben\,---\, wir tun das in 1-2 Minuten.


\dothis{Wähle deshalb den ersten Eintrag aus dem Menü, welcher bestätigt, dass wir wirklich \ct{zellenProSeite} meinen.}

Als Nächstes wird \squeak sich beschweren, dass es die Bedeutung von \ct{zellen} nicht kennt. Es bietet dir verschiedene Wege, das in Ordnung zu bringen. 


\dothis{Wähle \menu{declare instance}, weil wir \ct{zellen} als Instanzvariable haben wollen.}

Schließlich wird \squeak die Nachricht  \ct{neueZelleBei:bei:} beanstanden, die in der letzten Zeile steht. Das ist ebenfalls kein Fehler, also bestätigen wir diese Nachricht ebenfalls. 

\index{Variablendeklaration on the fly}
\index{Definition von Instanzvariablen} 

Wenn du dir jetzt wieder die Klassendefinition anschaust (was du tun kannst, indem du auf den  \button{instance}-Knopf klickst), siehst du, dass der Browser den Text modifiziert hat, indem er die Instanzvariable \ct{zellen} eingefügt hat.

Schauen wir uns die \ct{initialize}e-Methode an. Die Zeile \ct{|musterZelle breite hoehe n|} deklariert 4 temporäre Variablen. Sie heißen temporäre Variablen, weil ihre Gültigkeit und ihre Lebensdauer auf diese Methode beschränkt sind. Temporäre Variablen mit selbsterklärenden Namen sind hilfreich, um den Quelltext besser lesbar zu machen. Smalltalk hat keine Syntax, um zwischen Konstanten und Variablen zu unterscheiden, und genau genommen sind diese 4  ``Variablen'' eigentlich Konstanten. Zeilen 4--7 definieren diese Konstanten. 

Wie groß soll unser Spielfeld sein? Groß genug, um eine ganze Anzahl von Zellen aufzunehmen und groß genug, einen Rand darum zu zeichnen. Welche Anzahl von Zellen ist richtig? 5? 10? 100? wir wissen es jetzt nicht, und falls wir es wüssten, würden wir unsere Meinung wahrscheinlich später ändern. So delegieren wir die Verantwortlichkeit für die Anzahl der Zellen an eine andere Methode, die wir zellenProSeite nennen und die wir gleich schreiben werden. Weil wir die Nachricht \ct{zellenProSeite} senden, bevor wir eine Methode dieses Namens definieren, fordert \squeak uns auf ``confirm, correct, or cancel'' auszuwählen, wenn wir die Methode \ct{initialize} akzeptieren wollen. Lass dich davon nicht abschrecken, es ist eine gute Möglichkeit, im Hinblick auf Methoden zu schreiben, die noch nicht definiert sind. Warum? Nun, erst als wir die  \ct{initialize}-Methode geschrieben haben, haben wir festgestellt, dass wir die Methode brauchen. Wir können ihr bereits zu diesem Zeitpunkt einen sinnvollen Namen geben und weitermachen, ohne unseren Arbeitsablauf zu unterbrechen.

Die vierte Zeile nutzt diese Methode: der Smalltalk-Ausruck \ct{self zellenProSeite} sendet die Nachricht \ct{zellenProSeite} an \pvind{self}, das heißt an genau dieses Objekt. Die Antwort, die die Anzahl von Zellen pro Seite des Spielfeldes sein wird, wird \ct{n} zugewiesen.
Die nächsten drei Zeilen erzeugen das neue \ct{SBEZelle}-Objekt und weisen die Höhe und Breite den passenden temporären Variablen zu.

%The eighth line sends the message \ct{bounds:} to \self.
%\ct{bounds:} is a method that we inherit from our superclass; it is used to define the space on the screen that this Morph will occupy.  
%The single colon (\ct{:}) at the end of the name says that \ct{bounds:} expects a single parameter, which should be a rectangle object.

Zeile 8 legt die Begrenzung \ct{bounds}  des neuen Objektes fest. Ohne uns jetzt zu sehr um die Details zu kŸmmern, glaube uns einfach, dass der Ausdruck in den Klammern ein Quadrat mit dem Ursprung (\ie seine obere linke Ecke) am Punkt (5,5) hat und seine untere rechte Ecke weit genug entfernt ist, um ausreichend Platz fŸr die richtige Anzahl Zellen zu lassen. 

Die letzte Zeile weist in der Instanzvariable  \ct{zellen}  des  \ct{SBESpiel}-Objektes eine  \clsind{Matrix}  mit der richtigen Anzahl Zeilen und Spalten zu. Das kšnnen wir tun, indem wir die Nachricht \ct{new:tabulate:} an die \ct{Matrix} Klasse senden. (Klassen sind auch Objekte, deshalb können wir ihnen Nachrichten senden). Wir wissen dass \mthind{Matrix Klasse}{new:tabulate:} zwei Argumente braucht, das es zwei Doppelpunkte (\ct{:}) in seinem Namen hat.  Die Argumente folgen direkt auf die Doppelpunkte. 
Wenn du mit Programmiersprachen vertraut bist, die alle Argumente zusammen in Klammern setzen, wird dir das am Anfang eigenartig vorkommen. Aber keine Panik, das ist nur Syntax!
Es erweist sich als sehr gute Syntax, weil der Name der Methode verwendet werden kann, um die Rolle der Argumente zu erklŠren. Zum Beispiel ist es offensichtlich, dass \ct{Matrix rows: 5 columns: 2}  5 Zeilen und 2 Spalten hat und nicht 2 Zeilen und 5 Spalten.

\cmindex{Matrix Klasse}{rows:columns:}

\ct{Matrix new: n tabulate: [ :i :j | self neue ZelleBei: i bei: j ]} erzeugt eine neue \ct{n}{$\times$}\ct{n} matrix und initialisiert ihre Elemente. Der Startwert für jedes Element hängt von seinen Koordinaten ab. Das \ct{(i,j)}\textsuperscript{th} Element wird mit dem Ergebnis der Berechnung von \ct{self neueZelleBei: i bei: j} initialisiert.  

Das ist  \ct{initialize}.  Wenn du diesen Nachrichtenquelltext mit \menu{OK} akzeptierst kannst du die Gelegenheit nutzen, die Formatierung zu verschönern. Das musst du nicht per Hand machen: wähle  \menu{more \ldots \go prettyprint} aus dem gelben Mausmenü und der Browser wird das für dich tun. Danach musst du mit \menu{OK} die Methode nochmal Übersetzen oder kannst natürlich auch  \subind{keyboard shortcut}{abbrechen} (\short{l}\,---\, das ist ein kleines \emph{L}), wenn dir das Resultat nicht gefällt.  

Alternativ dazu kannst du den Browser auch so einrichten, dass er automatisch pretty-print nutzt, wenn er Quelltext anzeigt: verwende den Knopf ganz rechts in der Symbolleiste, um die Ansicht einzurichten.

\seeindex{pretty-print}{method}

Wenn du \menu{more\,\ldots} häfig benutzt, solltest du wissen, dass du die {\sc shift}  Taste beim Klicken gedrückt halten kannst, um direkt das \menu{more \ldots} Menü zu öffnen.

%=================================================================
\section{Methoden in Protokollen verwalten}

Bevor wir weitere Methoden definieren, wollen wir einen kurzen Blick auf die dritte Spalte oben im Browser werfen. So wie wir in der ersten Spalte des Browsers Klassen kategorisieren können, damit wir nicht von einer langen Liste von Klassennamen in der zweiten Spalte überwältigt werden, können wir in der dritten Spalte Methoden kategorisieren, so dass uns ncht eine lange Liste von Methodennamen in der vierten Spalte überwältigt. 

Diese Kategorien von Methoden heißen "Protokolle".
\index{protocol}

Wenn es nur wenige Methoden in einer Klasse gibt, ist die zusätzliche Hierarchie-Ebene durch die Protokolle nicht wirklich erforderlich. Darum bietet uns der Browser das virtuelle Protokoll \prot{-{}-all-{}-}, welches, wie du nicht allzu überrascht feststellen wirst, alle Methoden der Klasse enthält.
\protindex{all}

\begin{figure}[htbp]
   \centering
   \includegraphics[scale=0.7]{Categorize} 
   \caption{Kategorisieren aller nicht eingeordneten Methoden.\label{fig:categorize}}
\end{figure}

Wenn du dieses Beispiel weiter verfolgt hast, enthält die dritte Spalte jetzt ein Protokoll \protind{as yet unclassified}.

\dothis{Wähle aus dem \ind{gelben Mausmenü} den Eintrag \menu{categorize all uncategorized} um das zu beheben und bewege die \ct{initialize} Methode in ein neues Protokoll namens \protind{initialization}.}

Woher weiß \squeak{}, dass das das richtige Protokoll ist? Nun, im Prinzip kann \squeak{} das nicht wissen, aber in diesem Fallgibt es auch eine \ct{initialize}- Methode in einer übergeordneten Klasse und \squeak nimmt an, dass unsere Methode \ct{initialize} in die selbe Kategorie eingeordent werden soll wie diejenige, die sie überschreibt.
\index{method!categorize}

Möglicherweise stellst du fest, dass \squeak deine \ct{initialize}- Methode bereits in das Protokoll \protind{initialization} eingeordent hat. Wenn das so ist, dann liegt das daran, dass du ein Package namens \ct{AutomaticMethodCategorizer} in dein Image geladen hast.


\paragraph{Eine typographische Konvention.} Smalltalker nutzen häufig die Schreibweise ``\verb|>>|'', um die Klasse zu identifizieren, zu der eine Methode gehört. So würde die Methode \ct{zellenProSeite}  in der Klasse \ct{SBESpiel} beispielsweise durch \ct{SBESpiel>>zellenProSeite} referenziert werden. Um klarzustellen, dass das \emph{keine} \st Syntax ist, verwenden wir das Zeichen \ct{>>>} statt dessen, so dass diese Methode im Text als \ct{SBESpiel>>>zellenProSeite} erscheint.
\cmindex{Behavior}{>>}

Von jetzt an schreiben wir, wenn wir in diesem Buch eine Methode zeigen, den Namen der Methode in dieser Form.  Natürlich musst du, wenn du den Quelltext in den Browser schreibst, den Klassennamen oder \ct{>>>} nicht mitschreiben; statt dessen musst du nur sicherstellen, dass die entsprechende Klasse in der Klassenspalte ausgewählt ist.

Lass uns nun die anderen beiden Methoden definieren, die in der  Methode \ct{SBESpiel>>>initialize}  benutzt werden. Beide können in das Protokoll \prot{initialization} eingefügt werden.


\begin{method}[sbespielzellenproseite]{Eine Konstanten-Methode.}
SBESpiel>>>zellenProSeite
   "Die Anzahl von Zellen entlang jeder Seite des Spielbretts."
   ^ 10
\end{method}
\cmindex{SBESpiel}{zellenProSeite}
\index{constant methods}

Diese Methode könnte kaum einfacher sein: sie antwortet mit der Konstanten 10. Ein Vorteil der Darstellung von Konstanten durch Methoden ist, dass die Methode geändert werden kann und den Wert der Konstanten berechnet, wenn das Programm sich so weiterentwickelt, dass die Konstante von anderen Eigenschaften abhängt.

\needlines{10}
\begin{method}[neueZelleBei:bei:]{Eine Hilfsmethode für die Initialisierung}
SBESpiel>>>neueZelleBei: i bei: j
   "Erzeugt eine Zelle für Position (i,j) und fügt sie am Bildschirm an der passenden Position ein. Gibt eine neue Zelle zurück."
   | c ursprung |
   c := SBEZelle new.
   ursprung := self innerBounds origin.
   self addMorph: c.
   c position: ((i - 1) * c width) @ ((j - 1) * c height) + ursprung.
   c mausAktion: [self schalteNachbarnVonZelleBei: i bei: j ].
\end{method}
\cmindex{SBESpiel}{neueZelleBei:bei:}
%   ^ c      "omit this final line to create a bug"

\dothis{Füge die Methoden \ct{SBESpiel>>>zellenProSeite} and \ct{SBESpiel>>>neueZelleBei:bei:} hinzu.}
Bestätige die Schreibweise der neuen Selektoren \ct{schalteNachbarnVonZelleBei:bei:} und \ct{mausAktion:}.

\Mthref{neueZelleBei:bei:} gibt eine neue SBEZelle zurück, speziell an Position \ct{(i, j)} in der \clsind{Matrix} der Zellen.
Die letzte Zeile definiert, dass die \ct{mausAktion} der neuen Zelle der  \emph{Block}
\mbox{\lct{[self schalteNachbarnVonZelleBei: i bei: j ]}. ist}
Eigentlich legt dies das Antwortverhalten fest, was ausgeführt wird, wenn die Maustaste betätigt wird. Die korrespondierende Methode muss ebenfalls definiert werden.


\begin{method}[schalteNachbarnVonZelleBei:bei:]{Die callback- Methode.}
SBESpiel>>>schalteNachbarnVonZelleBei: i bei: j
   (i > 1) ifTrue: [ (zellen at: i - 1 at: j ) toggleState].
   (i < self zellenProSeite) ifTrue: [ (zellen at: i + 1 at: j) toggleState].
   (j > 1) ifTrue: [ (zellen at: i  at: j - 1) toggleState].
   (j < self zellenProSeite) ifTrue: [ (zellen at: i at: j + 1) toggleState].
\end{method}
\cmindex{SBESpiel}{schalteNachbarnVonZelleBei:bei:}

\Mthref{schalteNachbarnVonZelleBei:bei:} schaltet den Zustand der vier Zellen im Norden, Süden, Westen und Osten von Zelle (\ct{i}, \ct{j}) um.  Die einzige Komplikation liegt darin, dass das Spielfeld endlich ist und wir sicherstellen müssen, dass eine Nachbarzelle existiert, bevor ihren Zustand umschalten.


\dothis{Ordne diese Methode in ein neues Protokoll namens \prot{spiel logik} ein.\damien{this has to be explained. There were no explications before on how to create a new protocol.}}
Um eine Methode zu bewegen kannst du einfach auf ihren Namen klicken und sie in das neu erzeugte Protokoll ziehen. (\figref{dragMethod}).

\begin{figure}[htbp]
   \centering
   \ifluluelse
		{\includegraphics[width=\textwidth]{DragMethod} }
		{\includegraphics[scale=0.7]{DragMethod} }
   \caption{Ziehe eine Methode in ein Protokoll. \label{fig:dragMethod}}
\end{figure}

Um das Quinto-Spiel fertigzustellen, müssen wir noch zwei Methoden in der Klasse \ct{SBEZelle}  definieren, die sich um die Mausereignisse kümmern.

\begin{method}[mausAktion:]{Eine typische setter-Methode}
SBEZelle>>>mausAktion: einBlock
   ^ mausAktion := einBlock
\end{method}
\cmindex{SBEZelle}{mausAktion:}

\Mthref{mausAktion:} macht weiter nichts als der Variablen \ct{mausAktion} der Zelle das Argument zuzuweisen und dann den neuen Wert zurückzugeben.
Eine Methode die den Wert einer Instanzvariable \emph{ändert}, wird \emph{setter Methode} genannt; eine Methode die den aktuellen Wert einer Instanzvariable \emph{zurückgibt}, heißt \emph{getter-Methode}.

\seeindex{setter method}{accessor}
\seeindex{getter method}{accessor}

Wenn du getter und setter aus anderen Programmiersprachen kennst, erwartest du vielleicht, dass sie \ct{setmausAktion} und   \ct{getmausAktion} heißen. Die \st Konventionen sind anders. Ein getter hat immer den selben Namen wie die Variable, die er liest und ein setter ist ähnlich benannt, er hat nur ein angehängtes ``\ct{:}'', also  \ct{mausAktion} und \ct{mausAktion:}.

Gemeinsam werden beide,  setter und getter, als \emphind{accessor} Methoden bezeichnet, und sie sollten, der Konvention folgend, ins \protind{accessing} Protokoll eingeordnet werden.
In Smalltalk sind \emph{alle} Instanzvariablen in dem Objekt gekapselt, dem sie angehören, so dass der einzige Weg für andere Objekte, diese Variablen in Smalltalk zu lesen oder zu schreiben in derartigen accessor-Methoden besteht \footnote{Tatsächlich kann auf die Instanzvariablen auch in Unterklassen zugegriffen werden.}.


\dothis{Gehe zur Klasse \ct{SBEZelle}, definiere \ct{SBEZelle>>>mausAktion:} und lege sie in das \prot{accessing} Protokoll.}

Letztendlich müssen wir noch eine Methode \ct{mouseUp:} definieren; diese wird automatisch von der GUI-Umgebung aufgerufen, wenn die Maustaste losgelassen wird, während die Maus sich über dieser Zelle auf dem Bildschirm befindet.

\begin{method}[sbezellemouseup]{Eine Ereignisbehandlung}
SBECell>>>mouseUp: anEvent
   mausAktion value
\end{method}
\cmindex{SBEZelle}{mouseUp:}

\dothis{Füge die Methode \ct{SBEZelle>>>mouseUp:} hinzu und kategorisiere sie mit \menu{categorize all uncategorized} methods.}
\index{method!categorize}

Was diese Methode tut, ist, die Nachricht  \ct{value} an das Objekt zu senden, das in der Instanzvariable \ct{mausAktion} gespeichert ist.  
Erinnere dich, dass wir in \ct{SBESpiel>>>neueZelleBei: i bei: j} folgendes Quelltext-Fragment an \ct{mausAktion} zugewiesen haben:

\ct{[self schalteNachbarnVonZelleBei: i bei: j ]} 

\noindent
Das Senden der Nachricht \ct{value} veranlasst die Ausführung dieses Quelltext-Fragmentes und wird so konsequenterweise den Zustand der Zellen umschalten.

%=================================================================
\section{Lass uns unseren Quelltext ausführen}

Das wars: das Quinto-Spiel ist fertig!

Wenn du allen Schritten gefolgt bist, solltest du in der Lage sein, das Spiel, das aus nur 2 Kilassen und 7 Methoden besteht, zu spielen.

\dothis{Tippe \ct{SBESpiel new openInWorld} in einen Workspace und wähle \menu{Ausführen}.}

Das Spiel wird sich öffnen und du solltest auf die Zellen klicken können und sehen, wie es funktioniert.

Soviel zur Theorie \ldots{}
Wenn du auf eine Zelle klickst, erscheint ein  \emphind{Benachrichtigungs-} Fenster, genannt \clsind{PreDebugWindow} mit einer Fehlermeldung!
Wie in \figref{quintoError} dargestellt, zeigt es an  \ct{MessageNotUnderstood: SBESpiel>>>toggleState}.

\begin{figure}[ht]
\ifluluelse
	{\centerline{\includegraphics[width=\textwidth]{Error}}}
	{\centerline{\includegraphics[scale=0.7]{Error}}}
\caption{Es ist ein Fehler in unserem Spiel, wenn man auf eine Zelle klickt!}
\label{fig:quintoError}}
\end{figure}

\noindent
Was ist passiert? Um das herauszufinden wollen wir eines der mächtigeren Werkzeuge von Smalltalk nutzen: den \ind{Debugger}.

\dothis{Klicke auf den Knopf \menu{debug} im Benachrichtigungsfenster.}

Der Debugger wird sich öffnen. Im oberen Teil des Debugger-Fensters kann man den Ausführungs-Stack sehen, der alle aktiven Methoden anzeigt; wählt man eine davon aus, wird im mittleren Teil der Smalltalk-Quelltext angezeigt, der in dieser Methode ausgeführt wird, wobei der Teil, der den Fehler ausgelöst hat, markiert ist.


\dothis{Klicke auf die Zeile \ct{SBESpiel>>>schalteNachbarnVonZelleBei:bei:} (recht weit oben).}
der Debugger zeigt den  \ind{Ausführungskontext} in dieser Methode, wo der Fehler auftrat
(\figref{debugToggle}).

\begin{figure}[ht]
\ifluluelse
	{\centerline {\includegraphics[width=\textwidth]{Debugger}}}
	{\centerline {\includegraphics[scale=0.7]{Debugger}}}
\caption{Der Debugger, mit der Methode \ct{schalteNachbarnVonZelleBei:bei:} ausgewählt.
\label{fig:debugToggle}}
\end{figure}

Am unteren Ende des Debuggers sind zwei kleine Inspektor-Fenster. Links kannst du das Objekt untersuchen, das der Empfänger der Nachricht ist, die die selektierte Methode aufgerufen hat, man kann sich hier die Werte der Instanzvariablen ansehen. Rechts kann man das Objekt untersuchen, was die aktuell ausgeführte Methode selbst repräsentiert, so kann man sich hier die Werte der Methodenparameter und der temporären Variablen ansehen. 

Unter Verwendung des Debuggers kannst du den Quelltext Schritt für Schritt ausführen, Objekte in Parametern und lokale Variablen untersuchen, Quelltext genau wie im Workspace ausführen und, am überraschendsten für diejenigen, die andere Debugger kennen, den Quelltext ändern, während er debuggt wird! Manche Smalltalker programmieren immer im Debugger statt im Browser. Der Vorteil daran ist, dass du siehst, wie die Methode, die du schreibst, ausgeführt wird, mit echten Parametern im gegenwärtigen Ausführungskontext.

In diesem Fall können wir in der ersten Zeile  des oberen Bereiches sehen, dass die Nachricht \ct{toggleState} zu einer Instanz von \ct{SBESpiel} gesendet wurde, während es doch eindeutig eine Instanz der Klasse \lct{SBEZelle} sein sollte.
Das Problem liegt wahrscheinlich in der Initialisierung der \ct{zellen} Matrix.
Das Durchsuchen des Quelltextes von \cmind{SBESpiel}{initialize} zeigt, dass \ct{zellen}  mit dem Rückgabewert von \ct{neueZelleBei:bei:} belegt ist, aber wenn wir in dieser Methode nachsehen, sehen wir, dass es dort keinen Befehl für eine Rückgabe gibt! Standardmäßig gibt eine Methode \ct{self} zurück, was im Fall von \ct{neueZelleBei:bei:} in der Tat eine Instanz von SBESpiel} ist.

\index{method!returning self}

\dothis{Schließe das Debugger-Fenster. Füge den Ausdruck  ``\ct{^ c}'' an das Ende der Methode \ct{SBESpiel>>>neueZelleBei:bei:} an, so dass sie \ct{c} zurückgibt.
% It should now look as shown in \mthref{newCellAt:at:nobug}.}
(See \mthref{neueZelleBei:bei:nobug}.)}
% \needlines{6}
\begin{method}[neueZelleBei:bei:nobug]{Den Fehler beheben.}
SBESpiel>>>neueZelleBei: i bei: j
   "Erzeugt eine Zelle für Position (i,j) und fügt sie am Bildschirm an der passenden Position ein. Gibt eine neue Zelle zurück."
   | c ursprung |
   c := SBEZelle new.
   ursprung := self innerBounds origin.
   self addMorph: c.
   c position: ((i - 1) * c width) @ ((j - 1) * c height) + ursprung.
   c mausAktion: [self schalteNachbarnVonZelleBei: i bei: j ].
   ^ c
\end{method}
\cmindex{SBEGame}{newCellAt:at:}

\noindent
Erinnere dich aus \charef{quick} daran, dass das Konstrukt, um in Smalltalk  einen  \subind{Wert} aus einer  \subind{Methode}  \ind{zurück zu geben}   das \ct{^} ist, was du erhälst, indem du  \verb|^| tippst.

% \index{^@\verb|^|}
\index{^@{$\uparrow$}|see{return}}

Oftmals kannst du den Quelltext direkt im Debugger-Fenster berichtigen und dann \menu{Proceed} anklicken, um die Anwendung weiterlaufen zu lassen.
In unserem Fall ist es der einfachste Weg, den Debugger zu schließen, die laufende instanz des Spiels zu beenden (mit den \subind{Morphic}{Smarties}) und eine neue zu erzeugen, weil der Fehler bei der Initialisierung des Objektes aufgetreten ist und nicht in der fehlgeschlagenen Methode.

%Indeed, even in this case it would be possible to \menu{do} \ct{self initialize} and then \menu{Proceed} the \ct{toggleNeighboursOfCellAt:at:} method.
%\ab{St\'eph, did you try this?  It seems to me that it ought to work, but when I tried it, it messed up my image.}
% ON : It messed me up too!  Better not propose this.

\dothis{Führe: \ct{SBESpiel new openInWorld} nochmal aus.}
Nun sollte das Spiel ordentlich laufen.

%\sd{It would be good to have a word about the debugger buttons into, step.... Or to have a separate chapter, we would use the material I wrote for my turtle book, please check it.}
%\on{I think that is too much for this chapter. It will come soon enough.}

%=================================================================
\section{Smalltalk Quelltext sichern und verteilen}
\label{sec:Monticello}

Da nun das Quinto-Spiel funktioniert, möchtest du es sicher irgendwo speichern, so dass du es auch an deine Freunde weitergeben kannst. Natürlich kannst du dein gesamtes \squeak Image sichern und dein erstes Programm zeigen, indem du es dann laufen lässt, aber deine Freunde haben wahrscheinlich ihren eigenen Quelltext in ihren Image-Dateien und wollen den nicht verlieren, indem sie dein Image benutzen.  
Was du brauchst ist eine Möglichkeit, den Quelltext aus dem \squeak Image zu extrahieren, so dass andere Programmierer ihn in ihr Image einbinden können.

Der einfachste Weg, dies zu tun, ist das \emph{filing out} des Quelltextes. Das gelbe Mausmenü in der Spalte System-Kategorie bietet dir die Möglichkeit, die gesamte Kategorie \scat{SBE-Quinto} zu extrahieren. Die resultierende Datei ist mehr oder weniger gut lesbar, aber eigentlich für den Computer gedacht, nicht für den Menschen. Man kann dies per Email an seine Freunde schicken und diese können den Quelltext in ihr eigenes \squeak Image einbinden, indem sie den Dateilisten-Braowser verwenden.

\seeindex{saving code}{categories}
\seeindex{category!filing out}{file, filing out}
\seeindex{class!filing out}{file, filing out}
\seeindex{method!filing out}{file, filing out}
\index{file!filing out}

\dothis{KLicke auf die gelbe Maustaste i n der \scat{SBE-Quinto} Kategorie und wähle \menu{fileOut}.}
Jetzt solltest du eine Datei namens ``SBE-Quinto.st'' in selben Verzeichnis finden, in dem auch deine Image-Datei abgelegt ist. Sieh dir die Datei in einem Texteditor an.

\dothis{Öffne ein frisches \squeak Image und verwende das Dateilisten-Werkzeug mit \menu{file in}, um SBE-Quinto.st einzubinden. Stelle sicher, dass das SPiel nun auch in dem neuen Image funktioniert.}
\seeindex{category!filing in}{file, filing in}
\seeindex{class!filing in}{file, filing in}
\seeindex{method!filing in}{file, filing in}
\index{file!filing in}

\begin{figure}[ht]
\centerline {\includegraphics[width=\textwidth]{FileIn}}
\caption{Filing in \squeak source code.
\label{fig:filein}}
\end{figure}

\subsection{Monticello Packages}
Although fileouts are a convenient way of making a snapshot of the code you have written, they are decidedly ``old school''.
Just as most open-source projects find it much more convenient to maintain their code in a repository using \ind{CVS}\footnote{\url{www.nongnu.org/cvs}} or \ind{Subversion}\footnote{\url{subversion.tigris.org}},
so \squeak programmers find it more convenient to manage their code using \ind{Monticello} packages. 
These packages are represented as files with names ending in \ct{.mcz}; they are actually zip-compressed bundles that contain the complete code of your \ind{package}.

Using the Monticello package browser, you can save packages to repositories on various types of server, including FTP and HTTP servers; you can also just write the packages to a repository in a local file system directory.
A copy of your package is also always cached on your local hard-disk in the \emph{package-cache} folder. 
Monticello lets you save multiple versions of your program, merge versions, go back to an old version, and browse the differences between versions. 
In fact, Monticello is a distributed revision control system; this means it allows developers to save their work on different places, not on a single repository as it is the case with CVS or Subversion.\damien{Mercurial, Git are examples of distributed revision control system; not sure it's worth mentioning them.}
\seeindex{package browser}{Monticello}

You can also send a \ct{.mcz} file by email. 
The recipient will have to place it in her \emph{package-cache} folder; she will then be able to use Monticello to browse and load it. 
%(It is also possible to load it using the file list, but there is a difference between loading a \ct{.mcz} file using a file list and using Monticello \sd{check}.)

\dothis{Open the Monticello browser by selecting \menu{World \go open\,\ldots \go Monticello browser}.}
In the right-hand pane of the browser (see \figref{monticello1}) is a list of Monticello repositories, which will include all of the repositories from which code has been loaded into the image that you are using.  
%In addition to SqueakSource servers, Monticello repositories can live in a variety of other places, the simplest being a directory on your local disk.

\begin{figure}[hbt]
\ifluluelse
	{\centerline {\includegraphics[width=\textwidth]{MonticelloBrowser}}}
	{\centerline {\includegraphics[scale=0.7]{MonticelloBrowser}}}
\caption{The Monticello browser.
\label{fig:monticello1}}
\end{figure}

At the top of the list in the Monticello browser is a repository in a local directory called the \emphind{package cache}, which caches copies of the packages that you have loaded or published over the network. This local cache is really handy because it lets you keep your own local history; it also allows you to work in places where you do not have internet access, or where access is slow enough that you do not want to save to a remote repository very frequently.


\subsection{Saving and loading code with Monticello.}
On the left-hand side of the Monticello browser is a list of packages that have a version loaded into the image; packages that have been modified since they were loaded are marked with an asterisk.  (These are sometimes referred to as \subind{package}{dirty} packages.)  If you select a package, the list of repositories is restricted to just those repositories that contain a copy of the selected package.
\seeindex{*}{package, dirty}
\seeindex{dirty package}{package, dirty}

What is a package?  For now, you can think of a package as a group of  class and method categories that share the same prefix.  Since we put all of the code for the Quinto game into the class category called \scat{SBE-Quinto}, we can refer to it as the \ct{SBE-Quinto} package.

\dothis{Add the \ct{SBE-Quinto} package to your Monticello browser using the \button{+Package} button and type \ct{SBE-Quinto}.}

\subsection{\ind{SqueakSource}: a \ind{SourceForge} for \squeak.} 
We think that the best way to save your code and share it is to create an account for your project on a SqueakSource server. 
SqueakSource is like SourceForge\footnote{\url{www.sourceforge.net}}: it is a web front-end to a HTTP Monticello server that lets you manage your projects.
%In addition, SqueakSource includes a wiki, remote code browsing, RSS feed, admin right and access right management,   
% A number of {SqueakSource servers} around the Internet provide Monticello repositories and other facilities for development projects, including as a Wiki for documentation, remote code browsing, an RSS feed for update notification, and automatic publishing on SqueakMap.
\lr{- Automatic publishing on SqueakMap does not work reliable anymore (the SqueakMap API changed several times), so better remove this part (p. 53)}
There is a public SqueakSource server at \url{http://www.squeaksource.com}, and a copy of the code related to this book is stored there at \url{http://www.squeaksource.com/SqueakByExample.html}. You can look at this project with a web browser, but it's a lot more productive to do so from inside \squeak, using the Monticello browser, which lets you manage your packages.

\dothis{Open a web browser to \url{www.squeaksource.com}.
Create an account for yourself and then create (\ie ``register'') a project for the Quinto game.}
SqueakSource will show you the information that you should use when adding a repository using the Monticello browser. 

Once your project has been created on SqueakSource, you have to tell your \squeak system to use it. 

\dothis{With the \ct{SBE-Quinto} package selected, click the \button{+Repository} button in the Monticello browser.}  You will see a list of the different types of Repository that are available; to add a SqueakSource repository select \menu{HTTP}. You will be presented with a dialog in which you can provide the necessary information about the server.
You should copy the presented template to identify your SqueakSource project, paste it into Monticello and supply your initials and password:

\needlines{5}
\begin{code}{}
MCHttpRepository 
    location: 'http://www.squeaksource.com/!\emph{YourProject}!'
    user: '!\emph{yourInitials}!' 
    password: '!\emph{yourPassword}!'
\end{code}   

\noindent
If you provide empty initials and password strings, you can still load the project, but you will not be able to update it:

\needlines{5}
\begin{code}{}
MCHttpRepository 
    location: 'http://www.squeaksource.com/!\emph{YourProject}!'
    user: '' 
    password: ''
\end{code}   

%You can then load the code in your image by selecting the version you want. You can browse the code without loading it, using the \button{Browse} button.
Once you have accepted this template, your new repository should be listed on the right-hand side of the Monticello browser.

\begin{figure}[hbt]
\ifluluelse
	{\centerline {\includegraphics[width=\textwidth]{BrowseRepository}}}
	{\centerline {\includegraphics[scale=0.7]{BrowseRepository}}}
\caption{Browsing a Monticello Repository
\label{fig:monticello3}}
\end{figure}

\dothis{Click on the \button{Save} button to save a first version of your Quinto game on SqueakSource.}

To load a package into your image, you must first select a particular version.  You can do this in the repository browser, which you can open using the \button{Open} button or the yellow-button menu.  Once you have selected a version, you can load it onto your image.

\dothis{Open the \ct{SBE-Quinto} repository you have just saved.}

Monticello has many more capabilities, which will be discussed in depth in \charef{env}.
You can also look at the on-line documentation for Monticello at \url{http://www.wiresong.ca/Monticello/}.

%=================================================================
\section{Chapter summary}
In this chapter you have seen how to create categories, classes and methods.  You have see how to use the system browser, the inspector, the debugger and the Monticello browser.

\begin{itemize}
  \item Categories are groups of related classes.
  \item A new class is created by sending a message to its superclass.
  \item Protocols are groups of related methods.
  \item A new method is created or modified by editing its definition in the browser and then \emph{accepting} the changes.
  \item The inspector offers a simple, general-purpose GUI for inspecting and interacting with arbitrary objects.
  \item The system browser detects usage of undeclared methods and variables, and offers possible corrections.
  \item The \ct{initialize} method is automatically executed after an object is created in \squeak. You can put any initialization code there.
  \item The debugger provides a high-level GUI to inspect and modify the state of a running program.
  \item You can share source code \emph{filing out} a category.
  \item A better way to share code is to use Monticello to manage an external repository, for example defined as a SqueakSource project.
\end{itemize}

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================
%=================================================================
%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End:
